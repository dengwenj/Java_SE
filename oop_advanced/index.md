## 面向对象进阶

## static 静态变量
* static 表示静态，是 java 中的一个修饰符，可以修饰成员方法，成员变量
* 被 static 修饰的成员变量，叫做静态变量
* 特点：
* 共享的东西可以用静态变量
* 1、被该类所有对象【共享】
* 2、不属于对象，属于类
* 3、随着类的加载而加载，优先于对象存在
* 调用方式：
* 类名调用 Person.ss
* 对象调用

## static 静态方法
* 被 static 修饰的成员方法，叫做静态方法
* 特点：
* 1、多用在测试类和工具类中
* 2、javabean 类中很少会用
* 调用方式：
* 类名调用
* 对象调用

## 三种类
* javabean 类：用来描述一类事物的类，比如：Student、Dog
* 测试类：用来检查其他类是否书写正确，带有 main 方法的类，是程序的入口
* 工具类：不是用来描述一类事物的，而是帮我们做一些事情的类，Math...

## 工具类
* 类名见名知意
* 私有化构造方法
* 方法定义为静态
* 工具类帮助我解决各种各样事情的，只是一个工具，不需要创建它的对象。工具类是静态方法的一个使用场景
```java
public class ArrUtil {
    private ArrUtil() {}
    
    public static int getMax() {}
    public static int getMin() {}
    public static int getSum() {}
}
```
* 静态是随着类的加载而加载，优先于对象

## static 注意事项
* 静态方法只能访问静态变量和静态方法
* 非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法
* 静态方法中是没有 this 关键字
* 总结：
* 1、静态方法中，只能访问静态
* 2、非静态方法可以访问所有
* 3、静态方法中没有 this 关键字

## 重新认识 main 方法
```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
```
* public：被 JVM 调用，访问权限足够大
* static：被 JVM 调用，不用创建对象，直接类名访问，因为 main 方法是静态的，所以测试类中其他方法也需要时静态的
* void：被 JVM 调用，不需要给 JVM 返回值
* main：一个通用的名称，虽然不是关键字，但是被 JVM 识别
* String[] args：以前用于接收键盘录入数据的，现在没用

## 封装
* 对象代表什么，就得封装对应的数据，并提供数据对应的行为

## 继承
* java 中提供一个关键字 extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系
* public class Student extends Person {}
* Student 称为子类，Person 称为父类

## 什么时候用继承
* 当类与类之间，存在相同(共性)的内容，并满足子类时父类中的一种，就可以考虑使用集成，来优化代码

## 什么是继承、继承的好处
* 继承是面向对象三大特征之一，可以让类跟类之间产生子父的关系
* 可以把多个子类中重复的代码抽取到父类中，子类可以直接使用，减少代码冗余，提高代码的复用性

## 继承的格式
* public class 子类 extends 父类 {}

## 继承后子类的特点
* 子类可以得到父类的属性和行为，子类可以使用
* 子类可以在父类的基础上新增其他功能，子类更强大

## 继承的特点
* java 只能单继承：一个类只能继承一个直接父类
* java 不支持多继承、但是支持多层继承
* java 中所有的类都直接或者间接继承于 Object 类
* 子类只能访问父类中非私有的成员

* public 修饰的类名要与文件名一致

## 子类到底能继承父类中的哪些内容？
* 构造方法：非私有 不能，private 不能
* 成员变量：非私有 能，private 能只不过不能直接使用(get set)
* 成员方法：虚方法表 能，否则 不能

## 虚方法表
* 非 private、非 static、非 final

## 继承中：成员变量的访问特点
* 1、继承中成员变量访问特点：就近原则
* 先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
* 2、如果出现了重名的成员变量怎么办？
* name
* this.name
* super.name

## 继承中：成员方法的访问特点
* this调用：就近原则
* super调用：直接找父类

## 方法重写
* 当父类的方法不能满足子类现在的需求时，需要进行方法重写

## 书写格式
* 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法

## @Override 重写注解
* 1、@Override 是放在重写后的方法上，校验子类重写时语法是否正确
* 2、加上注解后如果有红色波浪写，表示语法错误
* 3、建议重写方法都加 @Override 注解，代码安全，优雅！

## 方法重写注意事项和要求
* 1、重写方法的名称、形参列表必须与父类中的一致
* 2、子类重写父类方法时，访问权限子类必须大于等于父类（空着不写 < protected < public）
* 3、子类重写父类方法时，返回值类型子类必须小于等于父类
* 4、重写的方法尽量和父类保持一致
* 5、只有被添加到虚方法表中的方法才能被重写
* 6、父类中的方法不能满足我们的需求了，所以需要进行重写

## 方法重写的本质
* 覆盖虚方法表中的方法