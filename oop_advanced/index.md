## 面向对象进阶

## static 静态变量
* static 表示静态，是 java 中的一个修饰符，可以修饰成员方法，成员变量
* 被 static 修饰的成员变量，叫做静态变量
* 特点：
* 共享的东西可以用静态变量
* 1、被该类所有对象【共享】
* 2、不属于对象，属于类
* 3、随着类的加载而加载，优先于对象存在
* 调用方式：
* 类名调用 Person.ss
* 对象调用

## static 静态方法
* 被 static 修饰的成员方法，叫做静态方法
* 特点：
* 1、多用在测试类和工具类中
* 2、javabean 类中很少会用
* 调用方式：
* 类名调用
* 对象调用

## 三种类
* javabean 类：用来描述一类事物的类，比如：Student、Dog
* 测试类：用来检查其他类是否书写正确，带有 main 方法的类，是程序的入口
* 工具类：不是用来描述一类事物的，而是帮我们做一些事情的类，Math...

## 工具类
* 类名见名知意
* 私有化构造方法
* 方法定义为静态
* 工具类帮助我解决各种各样事情的，只是一个工具，不需要创建它的对象。工具类是静态方法的一个使用场景
```java
public class ArrUtil {
    private ArrUtil() {}
    
    public static int getMax() {}
    public static int getMin() {}
    public static int getSum() {}
}
```
* 静态是随着类的加载而加载，优先于对象

## static 注意事项
* 静态方法只能访问静态变量和静态方法
* 非静态方法可以访问静态变量或静态方法，也可以访问非静态的成员变量和非静态的成员方法
* 静态方法中是没有 this 关键字
* 总结：
* 1、静态方法中，只能访问静态
* 2、非静态方法可以访问所有
* 3、静态方法中没有 this 关键字

## 重新认识 main 方法
```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}
```
* public：被 JVM 调用，访问权限足够大
* static：被 JVM 调用，不用创建对象，直接类名访问，因为 main 方法是静态的，所以测试类中其他方法也需要时静态的
* void：被 JVM 调用，不需要给 JVM 返回值
* main：一个通用的名称，虽然不是关键字，但是被 JVM 识别
* String[] args：以前用于接收键盘录入数据的，现在没用

## 封装
* 对象代表什么，就得封装对应的数据，并提供数据对应的行为

## 继承
* java 中提供一个关键字 extends，用这个关键字，我们可以让一个类和另一个类建立起继承关系
* public class Student extends Person {}
* Student 称为子类，Person 称为父类

## 什么时候用继承
* 当类与类之间，存在相同(共性)的内容，并满足子类时父类中的一种，就可以考虑使用集成，来优化代码

## 什么是继承、继承的好处
* 继承是面向对象三大特征之一，可以让类跟类之间产生子父的关系
* 可以把多个子类中重复的代码抽取到父类中，子类可以直接使用，减少代码冗余，提高代码的复用性

## 继承的格式
* public class 子类 extends 父类 {}

## 继承后子类的特点
* 子类可以得到父类的属性和行为，子类可以使用
* 子类可以在父类的基础上新增其他功能，子类更强大

## 继承的特点
* java 只能单继承：一个类只能继承一个直接父类
* java 不支持多继承、但是支持多层继承
* java 中所有的类都直接或者间接继承于 Object 类
* 子类只能访问父类中非私有的成员

* public 修饰的类名要与文件名一致

## 子类到底能继承父类中的哪些内容？
* 构造方法：非私有 不能，private 不能
* 成员变量：非私有 能，private 能只不过不能直接使用(get set)
* 成员方法：虚方法表 能，否则 不能

## 虚方法表
* 非 private、非 static、非 final

## 继承中：成员变量的访问特点
* 1、继承中成员变量访问特点：就近原则
* 先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
* 2、如果出现了重名的成员变量怎么办？
* name
* this.name
* super.name

## 继承中：成员方法的访问特点
* this调用：就近原则
* super调用：直接找父类

## 方法重写
* 当父类的方法不能满足子类现在的需求时，需要进行方法重写

## 书写格式
* 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法

## @Override 重写注解
* 1、@Override 是放在重写后的方法上，校验子类重写时语法是否正确
* 2、加上注解后如果有红色波浪写，表示语法错误
* 3、建议重写方法都加 @Override 注解，代码安全，优雅！

## 方法重写注意事项和要求
* 1、重写方法的名称、形参列表必须与父类中的一致
* 2、子类重写父类方法时，访问权限子类必须大于等于父类（空着不写 < protected < public）
* 3、子类重写父类方法时，返回值类型子类必须小于等于父类
* 4、重写的方法尽量和父类保持一致
* 5、只有被添加到虚方法表中的方法才能被重写
* 6、父类中的方法不能满足我们的需求了，所以需要进行重写

## 方法重写的本质
* 覆盖虚方法表中的方法

## 继承中：构造方法的访问特点
* 父类中的构造方法不会被子类继承，但是可以通过 super 调用
* 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己
* 为什么？
* 子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据
* 怎么调用父类构造方法？
* 子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行
* 如果想调用父类有参构造，必须手动写 super 进行调用

## this、super 使用总结
* this：理解为一个变量，表示当前方法调用者的地址值
* super：代表父类存储空间
* this 关键字：this.成员变量 访问本类成员变量、this.成员方法(...) 访问本类成员方法、this(...)访问本类构造方法
* super 关键字：super.成员变量 访问父类成员变量、super.成员方法(...) 访问父类成员方法、super(...)访问父类构造方法

## 什么是多态？
* 同类型的对象，表现出的不同形态。 对象的多种形态

## 多态的表现形式
* 父类类型 对象名称 = 子类对象

## 多态的前提
* 有继承/实现关系
* 有父类引用指向子类对象
* 有方法的重写

## 多态的好处
* 使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利

## 多态中调用成员的特点
* 调用成员变量的特点：编译看左边，运行也看左边（看的父类的成员变量）
* 调用成员方法的特点：编译看左边，运行看右边（编译的时候先看父类有没有这个方法，运行的时候看的子类的虚方法表中）

## 多态的优势
* 方法中，使用父类型作为参数，可以接收所有子类对象

## 多态的弊端
* 不能使用子类的特有功能

## 引用数据类型的类型转换，有几种方式
* 自动类型转换：Person p = new Student()
* 强制类型转换：Student s = (Student) p

## 强制类型转换能解决什么问题
* 可以转换成真正的子类类型，从而调用子类独有功能
* 转换类型与真实对象类型不一致会报错
* 转换的时候用 instanceof 关键字进行判断 a instanceof Dog

## final
* 方法：表示该方法是最终方法，不能被重写 public final void method() {};
* 类：表明该类是最终类，不能被继承 final class Person() {};
* 变量：叫做常量，只能被赋值一次 final int a = 1;

## 常量
* 实际开发中，常量一般作为系统的配置信息，方便维护，提高可读性
* 常量的命名规范：
* 1、单个单词：全部大写
* 2、多个单词：全部大写，单词之间用下划线隔开
* final 修饰的变量是基本数据类型：那么变量存储的数据值不能发生改变
* final 修饰的变量是引用数据类型：那么变量存储的地址值不能发生改变，对象内部的可以改变

## 权限修饰符
* 权限修饰符：是用来控制一个成员能够被访问的范围
* 可以修饰成员变量，方法，构造方法，内部类

## 权限修饰符的分类
* 有四种作用范围由小到大（private < 空着不写 < protected < public）
* 修饰符      同一个类中     同一个包中其他类      不同包下的子类      不同包下的无关类
* private     √
* 空着不写      √            √
* protected   √            √                  √
* public      √            √                  √                √

## 权限修饰符的使用规则
* 实际开发中，一般只用 private 和 public
* 成员变量私有
* 成员方法公开
* 特例：如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有

## 代码块的分类
* 局部代码块、构造代码块、静态代码块

## 局部代码块的作用
* 提前结束变量的生命周期（已淘汰）

## 构造代码块
* 1、写在成员位置的代码块
* 2、作用：可以把多个构造方法中重复的代码抽取出来
* 3、执行时机：我们在创建本类对象的时候会先执行构造代码块再执行构造方法

## 静态代码块
* 格式：static {}
* 特点：需要通过 static 关键字修饰，随着类的加载而加载，并且自动触发、只执行一次，可以数据初始化用

## 抽象类
* 如果一个类中存在抽象方法，那么该类就必须声明为抽象类

## 抽象方法
* 将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样，所以，在父类中不能确定具体的方法体，该方法就可以定义为抽象方法

## 抽象类和抽象方法的定义格式
* 抽象方法的定义格式：public abstract 返回值类型 方法名(参数列表);
* 抽象类的定义格式：public abstract class 类名 {}

## 抽象类和抽象方法的注意事项
* 抽象类不能实例化
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 可以有构造方法
* 抽象类的子类
* 1、要么重写抽象类中的所有抽象方法
* 2、要么是抽象类

## 抽象类和抽象方法的意义
* 强制子类必须按照这种格式进行重写，统一规范

## 为什么有接口？
* 接口：就是一种规则

## 接口的定义和使用
* 接口用关键字 interface 来定义
* public interface 接口名 {}
* 接口不能实例化
* 接口和类之间是实现关系，通过 implements 关键字表示
* public class 类名 implements 接口名 {}
* 接口的子类(实现类)
* 1、要么重写接口中的所有抽象方法
* 2、要么是抽象类
* 注意1：接口和类的视线关系，可以单实现，也可以多实现。public class 类名 implements 接口名1, 接口名2 {}
* 注意2：实现类还可以在继承一个类的同时实现多个接口 public class 类名 extends 父类 implements 接口名1, 接口名2 {}

## 接口中成员的特点
* 成员变量：只能是常量，默认修饰符：public static final
* 构造方法：没有
* 成员方法：jdk7以前，接口中只能定义抽象方法。默认修饰符：public abstract

## 接口和类之间的关系
* 类和类的关系：继承关系，只能单继承，不能多继承，但是可以多层继承
* 类和接口的关系：实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口
* 接口和接口的关系：继承关系，可以单继承，也可以多继承。如果实现类实现了最下面的子接口，那么就需要重写所有的抽象方法

## JDK8 以后接口中新增的方法
* 允许在接口中定义默认方法，需要使用关键字 default 修饰。作用：解决接口升级的问题
* 允许在接口中定义静态方法，需要用 static 修饰

## 接口中默认方法的定义格式
* 格式：public default 返回值类型 方法名(参数列表) {}
* 例：public default void show() {}

## 接口中静态方法的定义格式
* 格式：public static 返回值类型 方法名(参数列表) {}
* 例：public static void show() {}

## 接口中默认方法的注意事项：
* 1、默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉 default 关键字，实现类中去掉
* 2、public 可以省略，default 不能省略
* 3、如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写

## 接口中静态方法的注意事项
* 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
* public 可以省略，static 不能省略，接口中的静态方法不能被重写

## 接口
* 1、JDK7以前：接口中只能定义抽象方法
* 2、JDK8：接口中可以定义有方法体的方法（默认、静态）
* 3、JDK9：接口中可以定义私有方法
* 4、私有方法分为两种：成员私有方法，静态私有方法
* 5、接口代表规则，是行为的抽象，想要让哪个类拥有一个行为，就让这个类实现对应的接口就行
* 6、当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态
* 接口类型 j = new 实现类对象();
* public void method(接口 i) {}

## 适配器设计模式
* 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结
* 使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重要性
* 简单理解：设计模式就是各种套路
* 适配器设计模式：解决接口与接口实现类之间的矛盾问题

## 解决接口与接口实现类之间的矛盾问题
* 当一个接口中抽象方法过多，但是我只要使用其中一部分的时候，就可以适配器设计模式
* 书写步骤：
* 1、编写中间类 XxxAdapter，实现对应的接口
* 2、对接口中的抽象方法进行空实现
* 3、让真正的实现类继承中间类，并重写需要用的方法，为了避免其他类创建适配器类的对象，中间的适配器类用 abstract 进行修饰

## 类的五大成员
* 属性、方法、构造方法、代码块、内部类

## 内部类
* 内部类表示的事物是外部类的一部分
* 内部类单独出现没有任何意义
* 内部类的访问特点：
* 1、内部类可以直接访问外部类的成员，包括私有
* 2、外部类要访问内部类的成员，必须创建对象

## 什么是内部类
* 写在一个类里面的类就叫做内部类

## 什么时候用到内部类
* B 类表示的事物是 A 类的一部分，且 B类 单独存在没有意义
* 比如：汽车的发动机，ArrayList的迭代器

## 内部类的分类？
* 成员内部类、静态内部类、局部内部类、匿名内部类

## 什么是成员内部类？
* 写在成员位置的，属于外部类的成员

## 获取成员内部类对象的两种方式？
* 1、当成员内部类被 private 修饰时，在外部类编写方法，对外提供内部类对象
* 2、当成员内部类被非私有修饰时，直接创建对象。Outer.Inner oi = new Outer().new Inner();

## 外部类成员变量和内部类成员变量重名时，在内部类如何访问？
* Outer.this.变量名

## 静态内部类
* 静态内部类只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象
* 创建静态内部类对象的格式：外部类名.内部类名 对象名 = new 外部类名.内部类型();
* 调用非静态方法的格式：先创建对象，用对象调用
* 调用静态方法的格式：外部类名.内部类名.方法名()

## 局部内部类
* 1、将内部类定义在方法里面就叫做局部内部类，类似与方法里面的局部变量
* 2、外界是无法直接使用局部内部类，需要在方法内部创建对象并使用
* 3、该类可以直接访问外部类的成员，也可以访问方法内的局部变量

## 什么是匿名内部类
* 隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

## 匿名内部类的格式
* new 类名或者接口名() { 重写方法; };

## 格式的细节
* 包含了继承或实现，方法重写，创建对象
* 整体就是一个类的子类对象或者接口的实现类对象

## 使用场景
* 当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以用匿名内部类简化代码

## 枚举
* 枚举是一种特殊类
* 格式：
* 修饰符 enum 枚举类名 { 名称1, 名称2; 其他成员 }
* public enum A { X, Y, Z; }
* 枚举类中的第一行，只能写一些合法的标识符（名称），多个名称用逗号隔开
* 这些名称，本质是常量，每个常量都会记住枚举类的一个对象

## 枚举的特点
* 1、枚举类的第一行只能罗列一些名称，这些名称都是常量，并且每个常量记住的都是枚举类的一个对象
* 2、枚举类的构造器都是私有的（写不写都只能是私有的），因此，枚举对外不能创建对象
* 3、枚举都是最终类，不可以被继承
* 4、枚举类中，从第二行开始，可以定义类的其他各种成员
* 5、编译器为枚举类新增了几个方法，并且枚举类都是继承：java.lang.Enum 类的，从 enum 类也会继承到一些方法

## 枚举的常见应用场景
* 用来表示一组信息，然后作为参数进行传输
* 做信息标志和分类