## static
* static 表示静态，是 java 中的一个修饰符，可以修饰成员方法，成员变量
* 被 static 修饰的成员变量，叫做静态变量
* 特点：
* 1、被该类所有对象**共享**
* 2、不属于对象，属于类
* 3、随着类的加载而加载，优先于对象存在
* 调用方式：类名调用(推荐)，对象名调用

## static 的注意事项
* 静态方法只能访问静态变量和静态方法
* 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法
* 静态方法中是没有 this 关键字
* 静态方法中只能访问静态
* 非静态方法可以访问所有

## 继承
* 什么是继承、继承的好处？
* 1、继承是面向对象三大特征之一，可以让类跟类之间产生子父的关系
* 2、可以把多个子类中重复的代码抽取到父类中，子类可以直接使用，减少代码冗余，提高代码的复用性
* 继承的格式？
* public class 子类 extends 父类 {}
* 继承后子类的特点？
* 子类可以得到父类的属性和行为，子类可以使用
* 子类可以在父类的基础上新增其他功能，子类更强大
* java 只能单继承：一个类只能继承一个直接父类
* java 不支持多继承，但是支持多层继承
* java 中所有的类都直接或间接继承于 Object 类
* 画图：从下往上画
* 下面：子类
* 上面：父类
* 需要把子类中的共性内容抽取到父类中
* 核心：共性内容抽取，子类是父类中的一种
* 子类只能访问父类非私有的成员

## 子类到底能继承父类中的哪些内容？
* 构造方法：非私有 不能，private 不能
* 成员变量：非私有 能，private 能(但是不能直接用，需要用 get set 方法)
* 成员方法：虚方法表 能，否则 不能
* 虚方法表：非 private，非 static，非 final 可以放在 虚方法表中
* 只有父类中的虚方法才能被子类继承

## 继承中成员变量访问特点：就近原则
* 先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
* 如果出来了重名的成员变量怎么办？
* name：从局部位置开始往上找
* this.name： 从本类成员位置开始往上找
* super.name：从父类成员位置开始往上找

## 继承中成员方法的访问特点
* this 调用：就近原则
* super 调用：直接找父类

## 方法重写
* 当父类的方法不能满足子类现在的需求时，需要进行方法重写

## 书写格式
* 在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法重写的方法

## @Override 重写注解
* @Override 是放在重写后的方法上，校验子类重写时语法是否正确

## 方法重写注意事项和要求
* 1、重写方法的名称，形参列表必须与父类中的一致
* 2、子类重写父类方法时，访问权限子类必须大于等于父类
* 3、子类重写父类方法时，返回值类型子类必须小于等于父类
* 4、只有被添加到虚方法表中的方法才能被重写
* 方法重写的本质就是：覆盖了虚方法表中的方法

## 继承中：构造方法的访问特点
* 父类中的构造方法不会被子类继承
* 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己
* 为什么？
* 子类在初始化的时候，有可能会使用父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据
* 子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化

## 怎么调用父类构造方法的？
* 子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行
* 如果想调用父类有参构造，必须手动写 super 进行调用
 
## this、super 使用总结
* this：理解为一个变量，表示当前方法调用者的地址值
* super：代表父类存储空间
* this 访问本类构造方法：this()
* super 访问父类构造方法：super()

## 什么是多态？
* 对象的多种形态

## 多态的前提？
* 有继承/实现关系
* 有父类引用指向子类对象

## 多态的好处？
* 使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利

## 多态调用成员的特点
* 调用成员变量的特点：编译看左边，运行也看左边
* 调用成员方法的特点：编译看左边，运行看右边（因为是看的虚方法表中，虚方法表中有父类的方法）

## 多态的优势
* 在多态形式下，右边对象可以实现解耦合，便于扩展和维护
* 方法中，使用父类型作为参数，可以接收所有子类对象

## 多态的弊端
* 不能使用子类特有的方法
* 如何解决：强转

## 引用数据类型的类型转换，有几种方式
* 自动类型转换（小转大）、强制类型转换（大转小）

## 强制类型转换能解决什么问题？
* 可以转换成真正的子类类型，从而调用子类独有方法
* 转换类型与真实对象类型不一致会报错
* 转换的时候用 instanceof 关键字进行判断

## 包的作用
* 包就是文件夹，用来管理各种不同功能的 java 类

## 什么是全类名
* 包名 + 类名

## 什么时候需要导包，什么时候不需要导包
* 使用同一个包中的类时，不需要导包
* 使用 java.lang 包中的类时，不需要导包
* 如果同时使用两个包中的同名类，需要用全类名

## final
* 方法：表明该方法时最终方法，不能被重写
* 类：表明该类是最终类，不能被继承
* 变量：叫做常量，只能被赋值一次
* final 修饰的变量是基本类型：那么变量存储的数据值不能发生改变
* final 修饰的变量是引用类型：那么变量存储的地址值不能发生改变，对象内部的可以改变

## 权限修饰符的分类
* 有四种作用范围由小到大（private < 空着不写 < protected < public）
* 同一个类中：四种都可以
* 同一个包中其他类：private 不可以，其他三个可以
* 不同包下的子类：private，空着不写 不可以。另外两个可以
* 不同包下的无关类：只有 public 可以，其他不可以

## 代码块的分类
* 局部代码块、构造代码块、静态代码块
* 局部代码块：提前结束变量的生命周期
* 构造代码块：抽取构造方法中的重复代码
* 静态代码块的作用：随着类的加载而加载的，并只执行一次，做一些初始化的事情 static {}

## 抽象类和抽象方法
* 抽象方法：将共性的行为抽取到父类之后，由于每一个子类执行的内容是不一样，所以在父类中不能确定具体的方法体，该方法就可以定义为抽象方法
* 抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类

## 抽象类和抽象方法的注意事项
* 抽象类不能实例化
* 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类
* 可以有构造方法
* 抽象类的子类，要么重写抽象类中的所有抽象方法，要么也是抽象类

## 抽象类和抽象方法的意义
* 规范、统一，每个子类想要写同一个行为，那么方法名不会就是统一的，不会自己定义乱写
* 抽取共性时，无法确定方法体，就把方法定义为抽象的
* 强制让子类按照某种格式重写
```java
package vip.dengwj._abstract;

public abstract class Person {
    private String name;
    private int age;

    public abstract void work();
}

```

## 接口
* 接口就是一种规则，是对行为的抽象

## 接口的定义和使用
* 接口用关键字 interface 来定义：public interface 接口名 {}
* 接口不能实例化
* 接口和类之间是实现关系，通过 implements 关键字表示：public class 类名 implements 接口名 {}
* 接口的子类(实现类)，要么重写接口中的所有抽象方法，要么是抽象类
* 接口和类的实现关系，可以单实现，也可以多实现
* 实现类还可以在继承一个类的同时实现多个接口

## 接口中成员的特点
* 成员变量：只能是常量，默认修饰符：public static final
* 构造方法：没有
* 成员方法：只能是抽象方法，默认修饰符：public abstract

## 接口和类之间的关系
* 类和类的关系：继承关系，只能单继承，不能多继承，但是可以多层继承
* 类和接口的关系：实现关系，可以单实现，也可以多现实，还可以在继承一个类的同时实现多个接口
* 接口和接口的关系：继承关系，可以单继承，也可以多继承，如果实现类是实现了最下面的子接口，要重写这个体系所有的抽象方法

## JDk8 以后接口中新增的方法
* 允许在接口中定义默认方法，需要使用关键字 default 修饰，作用：解决接口升级的问题

## 接口中默认方法的定义格式
* 格式：public default 返回值类型 方法名(参数列表) {}

## 接口中默认方法的注意事项
* 默认方法不是抽象方法，所以不强制被重写，但是如果被重写，重写的时候去掉 default 关键字
* public 可以省略，default 不能省略
* 如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写

## 允许在接口中定义静态方法，需要用 static 修饰
* 接口中静态方法的定义格式：public static 返回值类型 方法名(参数列表) {}

## 接口中静态方法的注意事项
* 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
* public 可以省略，static 不能省略
* 子类把从父类继承下来的虚方法表里面的方法进行覆盖了，这才叫重写

## JDK9接口中可以定义私有方法
* 私有方法分为两种：普通的私有方法，静态的私有方法

## 总结
* 1、接口代表规则，是行为的抽象，想要让那个类拥有一个行为，就让这个类实现对应的接口就可以了
* 2、当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态
* 3、当一个接口中抽象方法过多，但是只要使用其中一部分的时候 ，就可以适配器设计模式
* 书写步骤：
* 1、编写中间类 XXXAdapter，实现对应的接口
* 2、对接口中的抽象方法进行空实现
* 3、让真正的实现类继承中间类，并重写需要用的方法
* 4、为了避免其他类创建适配器类的对象，中间的适配器类用 abstract 进行修饰

## 什么是内部类？
* 类的五大成员：属性、方法、构造方法、代码块、内部类
* 内部类表示的事物是外部类的一部分，内部类单独出现没有任何意义
* 内部类的访问特点：
* 1、内部类可以直接访问外部类的成员，包括私有
* 2、外部类要访问内部类的成员，必须创建对象

## 内部类的分类？
* 成员内部类，静态内部类，局部内部类，匿名内部类

## 什么是成员内部类？
* 写在成员位置的，属于外部类的成员

## 获取成员内部类对象的两种方式？
* 方式一：当成员内部类被 private 修饰时，在外部类编写方法，对外提供内部类对象
* 方式二：当成员内部类被非私有修饰时，直接创建对象。Outer.Inner oi = new Outer().new Inner()

## 外部类成员变量和内部类成员变量重名时，在内部类如何访问
* Outer.this.变量名