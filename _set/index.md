## Set 系列集合
* 无序：存取顺序不一致
* 不重复：可以去除重复
* 无索引：没有带索引的方法，所以不能使用普通 for 循环遍历，也不能通过索引来获取元素

## Set 集合的实现类
* HashSet：无序、不重复、无索引
* LinkedHashSet：有序、不重复、无索引
* TreeSet：可排序、不重复、无索引

## HashSet 底层原理
* HashSet 集合底层采取哈希表存储数据
* 哈希表是一种对于增删改查数据性能都较好的结构

## 哈希表组成
* JDK8 之前：数组 + 链表
* JDK8 开始：数组 + 链表 + 红黑树
 
## 哈希值
* 对象的整数表现形式
* 根据 hashCode 方法算出来的 int 类型的整数
* 该方法定义在 Object 类中，所有对象都可以调用，默认使用地址值进行计算
* 一般情况下，会重写 hashCode 方法，利用对象内部的属性值计算哈希值

## 对象的哈希值特点
* 如果没有重写 hashCode 方法，不同对象计算出的哈希值是不同的
* 如果已经重写 hashCode 方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
* 在小部分情况中，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样（哈希碰撞）

## HashSet 底层原理
* 1、创建一个默认长度 16，默认加载因子为 0.75 的数组（扩容），数组名 table
* 2、根据元素的哈希值跟数组的长度计算出应存入的位置
* 3、判断当前位置是否为 null，如果是 null 直接存入
* 4、如果位置不为 null，表示有元素，则调用 equals 方法比较属性值
* 5、一样：不存。不一样：存入数组，形成链表
* JDK8 以前：新元素存入数组，老元素挂在新元素下面
* JDK8 以后：新元素直接挂在老元素下面
* JDK8 以后，当链表长度超过8，而且数组长度大于等于64时，自动转换为红黑树
* 如果集合中存储的是自定义对象，必须要重写 hashCode 和 equals 方法

## 问题
* 1、HashSet 集合的底层数据结构是什么样的？
* 数组、链表、红黑树
* 2、HashSet 添加元素的过程？
* 上面的 HashSet 底层原理
* 3、HashSet 为什么存和取的顺序不一样
* 存的时候是根据 hashCode 和数组长度计算出索引的，不一定是按从小到大的
* 4、HashSet 为什么没有索引
* 不纯粹，底层用到了 数组、链表、红黑树
* 5、HashSet 是利用什么机制保证去重的？
* 重写 hashCode 和 equals 方法

## LinkedHashSet 底层原理
* 有序、不重复、无索引
* 这里的有序指的是保存存储和取出的元素顺序一致
* 原理：底层数据结构依然是哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序

## LinkedHashSet 集合的特点和原理是怎样的？
* 有序、不重复、无索引
* 底层基于哈希表，使用双链表记录添加顺序

## 以后如果要数据去重，使用哪个？
* 默认使用 Hash
* 如果要求去重且存取有序，才使用 LinkedHashSet

## TreeSet 的特点
* 不重复、无索引、可排序
* 可排序：按照元素的默认规则（从小到大）排序
* TreeSet 集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好

## TreeSet 集合默认的规则
* 对于数值类型：Integer、Double，默认按照从小到大的顺序进行排序
* 对于字符、字符串类型：按照字符在 ASCII 码表中的数字升序进行排序

## TreeSet 的两种比较方式 
* 方式一：默认排序/自然排序：javavean 类实现 Comparable 接口指定比较规则
* 方式二：创建 TreeSet 对象时候，传递比较器 Comparator 指定规则
* 使用原则：默认使用第一种，如果第一种不能满足当前需求，就使用第二种

## TreeSet 集合的特点是怎样的？
* 可排序、不重复、无索引
* 底层基于红黑树实现排序，增删改查性能较好

## TreeSet 集合自定义排序规则有几种方式
* 方式一：javabean 类实现 Comparable 接口，指定比较规则
* 方式二：创建集合时，自定义 Comparator 比较器对象，指定比较规则

## 方法返回值的特点
* 负数：表示当前要添加的元素是小的，存左边
* 正数：表示当前要添加的元素是大的，存右边
* 0：表示当前要添加的元素已经存在，舍弃

## 如果想要集合中的元素可重复
* 用 ArrayList 集合，基于数组的

## 如果想要集合中的元素可重复，而且当前的增删操作明显多于查询
* 用 LinkedList 集合，基于链表的

## 如果想对集合中的元素去重
* 用 HashSet 集合，基于哈希表的

## 如果想对集合中的元素去重，而且保证存取顺序
* 用 LinkedHashSet 集合，基于哈希表和双链表，效率低于 HashSet

## 如果想对集合中的元素进行排序
* 用 TreeSet 集合，基于红黑树，也可以用 List 实现排序