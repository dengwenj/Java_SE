## 异常
* 异常就是代表程序出现的问题，不是让我们以后不出现异常，而是程序出了异常之后，该如何处理

## Exception
* 叫做异常，代表程序可能出现的问题，我们通常会用 Exception 以及他的子类来封装程序出现的问题

## 运行时异常
* RuntimeException 及其子类，编译阶段不会出现异常提醒，运行时出现的异常（如：数组索引越界异常）

## 异常体系的最上层父类是谁？异常分为几类
* 父类：Exception
* 异常分为两类：编译时异常、运行时异常

## 编译时异常和运行时异常的区别？
* 编译时异常：没有继承 RuntimeException 的异常，直接继承于 Exception 编译阶段就会错误提示
* 编译时异常：除了 RuntimeException 和他的子类，其他都是编译时异常。编译阶段需要进行处理，作用在于提醒程序员检查本地信息
* 编译时异常：编译阶段就要进行处理的异常（如：日期解析异常）
* 运行时异常：RuntimeException 本身和子类，编译阶段没有错误提示，运行时出现的
* 运行时异常：编译阶段不需要处理，代码运行时出现的异常（如：数组索引越界异常）

## 异常的作用
* 1、异常是用来查询 bug 的关键参考信息
* 2、异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况

## 异常的处理方式
* 1、JVM 默认的处理方式
* 2、自己处理
* 3、抛出异常

## JVM 默认的处理方式
* 把异常的名称，异常原因及异常出现的位置等信息输出在了控制台
* 程序停止执行，下面的代码不会再在执行了

## 自己处理
* 格式：try { 可能出现异常的代码; } catch(异常类名 变量名) { 异常的处理代码 };
* 目的：当代码出现异常时，可以让程序继续往下执行

## 如果 try 中没有遇到问题，怎么执行？
* 会把 try 里面所有的代码全部执行完毕，不会执行catch 里面的代码
* 注意：只有当出现了异常才会执行 catch 里面的代码

## 如果 try 中可能会遇到多个问题，怎么执行
* 会写多个 catch 与之对应
* 细节：如果我们要捕获多个异常，这些异常中如果存在父子关系的话，那么父类一定要写在下面
* 在 JDK7之后，我们可以在 catch 中同时捕获多个异常，中间用 | 进行隔开，表示如果出现了 A 异常或者 B 异常的话，采取同一种处理方案

## 如果 try 中遇到的问题没有被捕获，怎么执行？
* 相当于 try...catch 的代码白写了，最终还是会交给虚拟机进行处理

## 如果 try 中遇到了问题，那么 try 下面的其他代码还会执行吗？
* 下面的代码就不会执行了，直接跳转到对应的 catch 当中，执行 catch 里面的语句体，但是如果没有对应 catch 与之匹配，那么还是会交给虚拟机进行处理

## 异常中常见的方法
* public String getMessage(); 返回此 throwable 的详细消息字符串
* public String toString(); 返回此可抛出的简短描述
* public void printStackTrace(); 在底层是利用 System.err.println 进行输出，把异常的错误信息输出在控制台，细节：仅仅是打印信息，不会停止程序运行
 
## 抛出异常
* throws：写在方法定义处，表示声明一个异常，告诉调用者，使用本方法可能有哪些异常
* throw：写在方法内，结束方法，手动抛出异常对象，交给调用者，方法中下面的代码不再执行了
* public void 方法() throws 异常类名1, 异常类名2... {}; 编译是异常：必须要写，运行时异常：可以不写
* public void 方法() { throw new NullPointerException(); }

## 虚拟机默认处理异常的方式
* 把异常信息以红色字体打印在控制台，并结束程序

## 捕获：try...catch
* 一般用在调用处，能让代码继续往下运行

## 抛出：throw、throws
* 在方法中，出现异常了，方法就没有继续运行下去的意义了，采取抛出处理，让该方法结束运行并告诉调用者出现了问题

## 自定义异常
* 定义异常类
* 写继承关系
* 空参构造
* 带参构造
* 就是为了让控制台的报错信息更加的见名知意
* 运行时：RuntimeException，核心表示由于参数错误而导致的问题
* 编译时：Exception 核心提醒程序员检查本地信息